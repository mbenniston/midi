/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package midi;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import midi.Data.ReadingUtils;

import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

class ReadingUtilsTests {
    private static final int TEST_STREAM_LENGTH = 8 * 1024;

    private static String createRandomString(int length) {
        StringBuilder builder = new StringBuilder();
        Random random = new Random();
        for (int i = 0; i < length; i++) {
            builder.append(random.nextInt(0xFF + 1));
        }
        return builder.toString();
    }

    private static byte[] createRandomBytes(int length) {
        byte[] bytes = new byte[length];
        new Random().nextBytes(bytes);
        return bytes;
    }

    private static int[] createRandomShorts(int length) {
        int[] shorts = new int[length];
        Random random = new Random();
        for (int i = 0; i < length; i++) {
            shorts[i] = random.nextInt(0, 0xFFFF + 1);
        }
        return shorts;
    }

    private static long[] createRandomUnsignedInts(int length) {
        return createRandomUnsignedInts(length, 0xFFFFFFFFL);
    }

    private static long[] createRandomUnsignedInts(int length, long maxInt) {
        long[] ints = new long[length];
        Random random = new Random();
        for (int i = 0; i < length; i++) {
            ints[i] = random.nextLong(0L, maxInt + 1L);
        }
        return ints;
    }

    private static long[] createRandomVariableLength(int length) {
        long[] ints = new long[length];
        Random random = new Random();
        for (int i = 0; i < length; i++) {
            ints[i] = random.nextLong(0L, (1L << (ReadingUtils.MAX_BITS_SUPPORTED_FOR_VARIABLE_PRECISION + 1))
                    - (1L << (ReadingUtils.MAX_BITS_SUPPORTED_FOR_VARIABLE_PRECISION)) + 1L);
        }
        return ints;
    }

    private static int getBytesUsedFromLong(long l) {
        int bytesUsed = Long.BYTES;

        while (bytesUsed != 0) {
            long currentByte = (l >>> (bytesUsed - 1) * 8) & 0xFF;
            if (currentByte == 0) {
                bytesUsed--;
            }
        }

        return bytesUsed;
    }

    private static void convertLongToVariableLength(long l, ArrayList<Byte> dest) {
        ArrayList<Byte> bytes = new ArrayList<>();

        long numSevenBits = (Long.BYTES / 7);

        for (int i = 0; i < numSevenBits; i++) {
            long b = (l >> (i * 7)) & 0x7FL;
            bytes.add((byte) b);
        }

        Collections.reverse(bytes);

        byte b;
        do {
            b = bytes.get(0);
            if (b == 0) {
                bytes.remove(0);
            }
        } while (b == (byte) 0 && !bytes.isEmpty());

        for (int i = 0; i < bytes.size(); i++) {

        }

        // long sevenBits;
        // long numSevenBits = (Long.BYTES / 7) * 7;
        // long offset = 0;
        // do {
        // sevenBits = (l >>> (numSevenBits - offset)) & 0xFE;
        // offset++;
        // } while (sevenBits == 0 && offset < numSevenBits);

        // for (long i = 0; i < (numSevenBits - offset); i++) {

        // long currentByte = (l >>> (numSevenBits - offset)) & 0xFE;
        // }

    }

    private static byte[] convertLongsToVariableLength(long[] longs) {
        ArrayList<Byte> bytes = new ArrayList<>();

        for (long l : longs) {
            convertLongToVariableLength(l, bytes);
        }

        byte[] bytes2 = new byte[bytes.size()];
        for (int i = 0; i < bytes.size(); i++) {
            bytes2[i] = bytes.get(i);
        }
        return bytes2;
    }

    @Test
    void readBytesFromRandomStream() {
        byte[] randomBytes = createRandomBytes(TEST_STREAM_LENGTH);
        InputStream randomStream = new ByteArrayInputStream(randomBytes);

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                for (int i = 0; i < TEST_STREAM_LENGTH; i++) {
                    assertEquals(randomBytes[i], ReadingUtils.readByte(randomStream));
                }
            }
        });

        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                ReadingUtils.readByte(randomStream);
            }
        });
    }

    @Test
    void readByteFromEmptyStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[0];
                ReadingUtils.readByte(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void byteToIntFullRange() {
        for (int i = 0; i < 256; i++) {
            assertEquals(
                    ReadingUtils.byteToInt((byte) i), i);
        }
    }

    @Test
    void byteToLongFullRange() {
        for (long i = 0; i < 256; i++) {
            assertEquals(
                    ReadingUtils.byteToLong((byte) i), i);
        }
    }

    @Test
    void readUnsignedShortFromEmptyStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[0];
                ReadingUtils.readUnsignedShort(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedShortFromIncompleteStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88 };
                ReadingUtils.readUnsignedShort(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedShortFromRandomStream() {
        int[] shorts = createRandomShorts(TEST_STREAM_LENGTH);

        byte[] streamBytes = new byte[shorts.length * 2];
        for (int i = 0; i < shorts.length; i++) {
            streamBytes[i * 2] = (byte) ((shorts[i] >>> 8) & 0xFF);
            streamBytes[i * 2 + 1] = (byte) (shorts[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                for (int i = 0; i < shorts.length; i++) {
                    assertEquals(shorts[i], ReadingUtils.readUnsignedShort(randomStream));
                }
            }
        });

        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                ReadingUtils.readUnsignedShort(randomStream);
            }
        });
    }

    @Test
    void readUnsignedShortFullRange() {
        final int NUM_SHORTS = 0xFFFF + 1; // includes zero

        byte[] streamBytes = new byte[2];
        for (int i = 0; i < NUM_SHORTS; i++) {
            final int expectedShort = i;
            streamBytes[0] = (byte) ((i >>> 8) & 0xFF);
            streamBytes[1] = (byte) (i & 0xFF);

            InputStream randomStream = new ByteArrayInputStream(streamBytes);

            assertDoesNotThrow(new Executable() {
                @Override
                public void execute() throws Throwable {
                    assertEquals(expectedShort, ReadingUtils.readUnsignedShort(randomStream));
                }
            });

            assertThrowsExactly(IOException.class, new Executable() {
                @Override
                public void execute() throws Throwable {
                    ReadingUtils.readUnsignedShort(randomStream);
                }
            });
        }
    }

    @Test
    void readUnsignedIntFromEmptyStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[0];
                ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedIntFromIncompleteStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88 };
                ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
            }
        });
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66 };
                ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
            }
        });
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66, 0x11 };
                ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedIntFromRandomStream() {
        long[] unsignedInts = createRandomUnsignedInts(TEST_STREAM_LENGTH);

        byte[] streamBytes = new byte[unsignedInts.length * 4];
        for (int i = 0; i < unsignedInts.length; i++) {
            streamBytes[i * 4] = (byte) ((unsignedInts[i] >>> 24) & 0xFF);
            streamBytes[i * 4 + 1] = (byte) ((unsignedInts[i] >>> 16) & 0xFF);
            streamBytes[i * 4 + 2] = (byte) ((unsignedInts[i] >>> 8) & 0xFF);
            streamBytes[i * 4 + 3] = (byte) (unsignedInts[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                for (int i = 0; i < unsignedInts.length; i++) {
                    assertEquals(unsignedInts[i], ReadingUtils.readUnsignedInt(randomStream));
                }
            }
        });

        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                ReadingUtils.readUnsignedInt(randomStream);
            }
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromEmptyStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[0];
                ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromIncompleteStream() {
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88 };
                ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
            }
        });
        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66 };
                ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
            }
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromRandomStream() {
        long[] UnsignedIntFrom3Bytess = createRandomUnsignedInts(TEST_STREAM_LENGTH, 0x00FFFFFFL);

        byte[] streamBytes = new byte[UnsignedIntFrom3Bytess.length * 3];
        for (int i = 0; i < UnsignedIntFrom3Bytess.length; i++) {
            streamBytes[i * 3] = (byte) ((UnsignedIntFrom3Bytess[i] >>> 16) & 0xFF);
            streamBytes[i * 3 + 1] = (byte) ((UnsignedIntFrom3Bytess[i] >>> 8) & 0xFF);
            streamBytes[i * 3 + 2] = (byte) (UnsignedIntFrom3Bytess[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                for (int i = 0; i < UnsignedIntFrom3Bytess.length; i++) {
                    assertEquals(UnsignedIntFrom3Bytess[i], ReadingUtils.readUnsignedIntFrom3Bytes(randomStream));
                }
            }
        });

        assertThrowsExactly(IOException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                ReadingUtils.readUnsignedIntFrom3Bytes(randomStream);
            }
        });
    }

    @Test
    void readStringFromEmptyStream() {
        byte[] bytes = new byte[] {};
        InputStream randomStream = new ByteArrayInputStream(bytes);

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                assertEquals("", ReadingUtils.readString(randomStream, 0));
            }
        });
    }

    @Test
    void readStringFromRandomStream() {
        String randomString = createRandomString(TEST_STREAM_LENGTH);
        InputStream randomStream = new ByteArrayInputStream(randomString.getBytes());

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                assertEquals(randomString, ReadingUtils.readString(randomStream, randomString.length()));
            }
        });
    }

    // @Test
    // void readVariableLengthFromRandomStream() {
    // long[] values = createRandomVariableLength(1);

    // InputStream randomStream = new
    // ByteArrayInputStream(convertLongsToVariableLength(values));

    // byte[] bytes = convertLongsToVariableLength(values);

    // assertDoesNotThrow(new Executable() {
    // @Override
    // public void execute() throws Throwable {
    // for (long value : values) {
    // assertEquals(value, ReadingUtils.readVariableLength(randomStream));
    // }
    // }
    // });
    // }

    @Test
    void readVariableLengthFromickedExamples() {
        final long[] values = new long[] {
                0,
                7,
                127,
                128,
                8192,
                16383,
                16384,
                106903,
                1000000,
                2097151,
                134217728,
                268435455
        };
        InputStream stream = new ByteArrayInputStream(
                new byte[] {
                        (byte) 0x00, (byte) 0x07, (byte) 0x7f, (byte) 0x81, 0x00, (byte) 0xC0, 0x00, (byte) 0xff, 0x7f,
                        (byte) 0x81, (byte) 0x80, (byte) 0x00, (byte) 0x86, (byte) 0xc3, (byte) 0x17,
                        (byte) 0xbd, (byte) 0x84, (byte) 0x40, (byte) 0xff, (byte) 0xff, (byte) 0x7f, (byte) 0xC0,
                        (byte) 0x80, (byte) 0x80, (byte) 0x00, (byte) 0xFF,
                        (byte) 0xFF, (byte) 0xFF, (byte) 0x7F
                });

        assertDoesNotThrow(new Executable() {
            @Override
            public void execute() throws Throwable {
                for (long value : values) {
                    assertEquals(value, ReadingUtils.readVariableLength(stream));
                }
            }
        });
    }

    @Test
    void readVariableLengthFromInvalidNumber() {

    }

    @Test
    void readVariableLengthUntilOutOfPrecision() {

    }

}