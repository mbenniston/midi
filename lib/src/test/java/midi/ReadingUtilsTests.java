/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package midi;

import org.junit.jupiter.api.Test;

import midi.Reading.ReadingUtils;

import static org.junit.jupiter.api.Assertions.*;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

import static midi.TestUtils.*;

class ReadingUtilsTests {
    private static final int TEST_STREAM_LENGTH = 1024;

    @Test
    void readBytesFromRandomStream() {
        byte[] randomBytes = createRandomBytes(TEST_STREAM_LENGTH);
        InputStream randomStream = new ByteArrayInputStream(randomBytes);

        assertDoesNotThrow(() -> {
            for (int i = 0; i < TEST_STREAM_LENGTH; i++) {
                assertEquals(randomBytes[i], ReadingUtils.readByte(randomStream));
            }
        });

        assertThrowsExactly(IOException.class, () -> {
            ReadingUtils.readByte(randomStream);
        });

    }

    @Test
    void readByteFromEmptyStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[0];
            ReadingUtils.readByte(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void byteToIntFullRange() {
        for (int i = 0; i < 256; i++) {
            assertEquals(
                    ReadingUtils.byteToInt((byte) i), i);
        }
    }

    @Test
    void byteToLongFullRange() {
        for (long i = 0; i < 256; i++) {
            assertEquals(
                    ReadingUtils.byteToLong((byte) i), i);
        }
    }

    @Test
    void readUnsignedShortFromEmptyStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[0];
            ReadingUtils.readUnsignedShort(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedShortFromIncompleteStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88 };
            ReadingUtils.readUnsignedShort(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedShortFromRandomStream() {
        int[] shorts = createRandomShorts(TEST_STREAM_LENGTH);

        byte[] streamBytes = new byte[shorts.length * 2];
        for (int i = 0; i < shorts.length; i++) {
            streamBytes[i * 2] = (byte) ((shorts[i] >>> 8) & 0xFF);
            streamBytes[i * 2 + 1] = (byte) (shorts[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(() -> {
            for (int i = 0; i < shorts.length; i++) {
                assertEquals(shorts[i], ReadingUtils.readUnsignedShort(randomStream));
            }
        });

        assertThrowsExactly(IOException.class, () -> {
            ReadingUtils.readUnsignedShort(randomStream);
        });
    }

    @Test
    void readUnsignedShortFullRange() {
        final int NUM_SHORTS = 0xFFFF + 1; // includes zero

        byte[] streamBytes = new byte[2];
        for (int i = 0; i < NUM_SHORTS; i++) {
            final int expectedShort = i;
            streamBytes[0] = (byte) ((i >>> 8) & 0xFF);
            streamBytes[1] = (byte) (i & 0xFF);

            InputStream randomStream = new ByteArrayInputStream(streamBytes);

            assertDoesNotThrow(() -> {
                assertEquals(expectedShort, ReadingUtils.readUnsignedShort(randomStream));
            });

            assertThrowsExactly(IOException.class, () -> {
                ReadingUtils.readUnsignedShort(randomStream);
            });
        }
    }

    @Test
    void readUnsignedIntFromEmptyStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[0];
            ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedIntFromIncompleteStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88 };
            ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
        });

        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66 };
            ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
        });
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66, 0x11 };
            ReadingUtils.readUnsignedInt(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedIntFromRandomStream() {
        long[] unsignedInts = createRandomUnsignedInts(TEST_STREAM_LENGTH);

        byte[] streamBytes = new byte[unsignedInts.length * 4];
        for (int i = 0; i < unsignedInts.length; i++) {
            streamBytes[i * 4] = (byte) ((unsignedInts[i] >>> 24) & 0xFF);
            streamBytes[i * 4 + 1] = (byte) ((unsignedInts[i] >>> 16) & 0xFF);
            streamBytes[i * 4 + 2] = (byte) ((unsignedInts[i] >>> 8) & 0xFF);
            streamBytes[i * 4 + 3] = (byte) (unsignedInts[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(() -> {
            for (int i = 0; i < unsignedInts.length; i++) {
                assertEquals(unsignedInts[i], ReadingUtils.readUnsignedInt(randomStream));
            }
        });

        assertThrowsExactly(IOException.class, () -> {
            ReadingUtils.readUnsignedInt(randomStream);
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromEmptyStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[0];
            ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromIncompleteStream() {
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88 };
            ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
        });
        assertThrowsExactly(IOException.class, () -> {
            byte[] emptyBytes = new byte[] { (byte) 0x88, 0x66 };
            ReadingUtils.readUnsignedIntFrom3Bytes(new ByteArrayInputStream(emptyBytes));
        });
    }

    @Test
    void readUnsignedIntFrom3BytesFromRandomStream() {
        long[] UnsignedIntFrom3Bytess = createRandomUnsignedInts(TEST_STREAM_LENGTH, 0x00FFFFFFL);

        byte[] streamBytes = new byte[UnsignedIntFrom3Bytess.length * 3];
        for (int i = 0; i < UnsignedIntFrom3Bytess.length; i++) {
            streamBytes[i * 3] = (byte) ((UnsignedIntFrom3Bytess[i] >>> 16) & 0xFF);
            streamBytes[i * 3 + 1] = (byte) ((UnsignedIntFrom3Bytess[i] >>> 8) & 0xFF);
            streamBytes[i * 3 + 2] = (byte) (UnsignedIntFrom3Bytess[i] & 0xFF);
        }
        InputStream randomStream = new ByteArrayInputStream(streamBytes);

        assertDoesNotThrow(() -> {
            for (int i = 0; i < UnsignedIntFrom3Bytess.length; i++) {
                assertEquals(UnsignedIntFrom3Bytess[i], ReadingUtils.readUnsignedIntFrom3Bytes(randomStream));
            }
        });

        assertThrowsExactly(IOException.class, () -> {
            ReadingUtils.readUnsignedIntFrom3Bytes(randomStream);
        });
    }

    @Test
    void readStringFromEmptyStream() {
        byte[] bytes = new byte[] {};
        InputStream randomStream = new ByteArrayInputStream(bytes);

        assertDoesNotThrow(() -> {
            assertEquals("", ReadingUtils.readString(randomStream, 0));
        });
    }

    @Test
    void readStringFromRandomStream() {
        String randomString = createRandomString(TEST_STREAM_LENGTH);
        InputStream randomStream = new ByteArrayInputStream(randomString.getBytes());

        assertDoesNotThrow(() -> {
            assertEquals(randomString, ReadingUtils.readString(randomStream, randomString.length()));
        });
    }

    @Test
    void readVariableLengthFromPickedExamples() {
        final long[] values = new long[] {
                0,
                7,
                127,
                128,
                8192,
                16383,
                16384,
                106903,
                1000000,
                2097151,
                134217728,
                268435455
        };

        InputStream stream = new ByteArrayInputStream(
                new byte[] {
                        (byte) 0x00, (byte) 0x07, (byte) 0x7f, (byte) 0x81, 0x00, (byte) 0xC0, 0x00, (byte) 0xff, 0x7f,
                        (byte) 0x81, (byte) 0x80, (byte) 0x00, (byte) 0x86, (byte) 0xc3, (byte) 0x17,
                        (byte) 0xbd, (byte) 0x84, (byte) 0x40, (byte) 0xff, (byte) 0xff, (byte) 0x7f, (byte) 0xC0,
                        (byte) 0x80, (byte) 0x80, (byte) 0x00, (byte) 0xFF,
                        (byte) 0xFF, (byte) 0xFF, (byte) 0x7F
                });

        assertDoesNotThrow(() -> {
            for (long value : values) {
                assertEquals(value, ReadingUtils.readVariableLength(stream));
            }
        });
    }

    @Test
    void readVariableLengthFromRandomStream() {
        long[] values = createRandomVariableLength(TEST_STREAM_LENGTH);

        InputStream randomStream = new ByteArrayInputStream(convertLongsToVariableLength(values));

        assertDoesNotThrow(() -> {
            for (long value : values) {
                assertEquals(value, ReadingUtils.readVariableLength(randomStream));
            }
        });
    }

    @Test
    void readVariableLengthFromInvalidNumber() {
        final byte nonTerminalByte = (byte) 0x80;

        byte[] bytes = new byte[ReadingUtils.MAX_READABLE_BYTES_FOR_VARIABLE_PRECISION + 1];
        for (int i = 0; i < bytes.length; i++) {
            bytes[i] = nonTerminalByte;
        }
        InputStream stream = new ByteArrayInputStream(bytes);

        assertThrows(IOException.class, () -> {
            ReadingUtils.readVariableLength(stream);
        });
    }

    @Test
    void readVariableLengthUntilOutOfPrecision() {
        final byte nonTerminalByte = (byte) 0x80;
        final byte terminalByte = (byte) 0x00;

        byte[] bytes = new byte[ReadingUtils.MAX_READABLE_BYTES_FOR_VARIABLE_PRECISION + 1];
        for (int i = 0; i < bytes.length - 1; i++) {
            bytes[i] = nonTerminalByte;
        }
        bytes[bytes.length - 1] = terminalByte;

        InputStream stream = new ByteArrayInputStream(bytes);

        assertThrows(IOException.class, () -> {
            ReadingUtils.readVariableLength(stream);
        });
    }

    @Test
    void readVariableLengthUntilAtPrecisionEdge() {
        final byte nonTerminalByte = (byte) 0x80;
        final byte terminalByte = (byte) 0x00;

        byte[] bytes = new byte[ReadingUtils.MAX_READABLE_BYTES_FOR_VARIABLE_PRECISION];
        for (int i = 0; i < bytes.length - 1; i++) {
            bytes[i] = nonTerminalByte;
        }
        bytes[bytes.length - 1] = terminalByte;

        InputStream stream = new ByteArrayInputStream(bytes);

        assertDoesNotThrow(() -> {
            assertEquals(0, ReadingUtils.readVariableLength(stream));
        });
    }
}